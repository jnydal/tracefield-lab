export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    // Only do this for your site route (safety)
    if (url.hostname !== "tracefieldlab.thor-nydal.no") {
      return fetch(request);
    }

    // ---- IMPORTANT: bypass OAuth/SSO callback routes ----
    const bypassPaths = [
      "/auth/callback",
      "/oauth/callback",
      "/oauth2/callback",
      "/signin-google",
      "/api/auth",
      "/api/auth/callback",
    ];

    const shouldBypass =
      bypassPaths.some((p) => url.pathname === p || url.pathname.startsWith(p)) ||
      url.searchParams.has("code") ||
      url.searchParams.has("state");

    if (shouldBypass) {
      return fetch(request);
    }

    // Avoid waking on every asset request
    const accept = request.headers.get("accept") || "";
    const isPage = accept.includes("text/html") || url.pathname === "/";

    if (!isPage) {
      return fetch(request);
    }

    // Prevent recursion
    const alreadyTried = request.headers.get("x-wake-tried") === "1";
    const req2 = new Request(request, { headers: new Headers(request.headers) });
    req2.headers.set("x-wake-tried", "1");

    if (alreadyTried) {
      return fetch(request);
    }

    // Try origin once
    try {
      const resp = await fetch(req2, { cf: { cacheTtl: 0 } });
      if (resp.ok) return resp;
    } catch (_) {}

    // Wake via direct port-forwarded ESP32 endpoint
    const WAKE_URL = "http://178.232.69.55:57986/wake";
    const WAKE_KEY = env.WAKE_KEY || "9corrigatE!"; // keep in env if possible
    const wakeUrlWithKey = `${WAKE_URL}?key=${encodeURIComponent(WAKE_KEY)}`;

    console.log("WAKE: calling ESP32", WAKE_URL);

    // Add a timeout so the Worker doesn't hang
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), 3000); // 3s timeout

    try {
      const r = await fetch(wakeUrlWithKey, {
        method: "GET",
        cf: { cacheTtl: 0 },
        signal: controller.signal,
        headers: {
          // Optional: helps some routers/NATs/logs
          "user-agent": "cf-worker-wake/1.0",
        },
      });
      console.log("WAKE: ESP32 status", r.status);
    } catch (e) {
      console.log("WAKE: ESP32 call failed", String(e));
    } finally {
      clearTimeout(t);
    }

    // Friendly "waking up" page + auto refresh
    return new Response(
      `<!doctype html>
<html><head>
<meta charset="utf-8">
<meta http-equiv="refresh" content="15">
<title>Waking server...</title>
</head>
<body style="font-family:system-ui;padding:2rem">
<h2>Waking the server…</h2>
<p>Please wait ~15–60 seconds. This page will refresh automatically.</p>
</body></html>`,
      { headers: { "content-type": "text/html; charset=utf-8" }, status: 503 }
    );
  },
};
